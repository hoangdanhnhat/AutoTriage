Automated Triage Collection System - Complete Build Guide
Project Structure
IRTriageCollector/
├── Core/
│   ├── Main-Collector.ps1          # Main orchestration script
│   ├── Config.ps1                   # Configuration settings
│   └── Logger.ps1                   # Logging functions
├── Modules/
│   ├── VolatileData.ps1            # Memory, processes, network
│   ├── RegistryCollection.ps1       # Registry hives
│   ├── EventLogCollection.ps1       # Event logs
│   ├── FileSystemArtifacts.ps1      # Prefetch, MFT, etc.
│   └── ChainOfCustody.ps1          # Documentation & hashing
├── Utils/
│   ├── Compression.ps1              # Archive creation
│   ├── Validation.ps1               # Privilege & space checks
│   └── ExternalTools.ps1            # Third-party tool wrappers
├── Output/
│   └── [timestamp]_[hostname]/      # Collection results
├── Tools/                           # External binaries
│   ├── DumpIt.exe                   # Memory dumper
│   ├── RawCopy.exe                  # Locked file copier
│   └── autorunsc.exe                # Sysinternals tool
├── Logs/                            # Execution logs
├── Reports/                         # HTML/JSON reports
└── README.md                        # Documentation
Phase 1: Project Setup & Planning (Week 1)
Step 1.1: Define Requirements

List all artifacts to collect (prioritize by volatility)
Determine minimum Windows version support (Win 10/Server 2016+)
Define output formats (raw files + JSON metadata)
Plan storage requirements (estimate 2-10GB per collection)
Decide on administrator privilege handling

Step 1.2: Environment Setup
powershell# Create project structure
New-Item -ItemType Directory -Path @(
    "IRTriageCollector/Core",
    "IRTriageCollector/Modules",
    "IRTriageCollector/Utils",
    "IRTriageCollector/Tools",
    "IRTriageCollector/Output",
    "IRTriageCollector/Logs",
    "IRTriageCollector/Reports"
)

# Initialize Git repository
git init
Step 1.3: Gather External Tools
Download and place in Tools/ folder:

DumpIt or WinPMEM for memory acquisition
RawCopy for locked file copying
Sysinternals tools (optional but recommended)

Phase 2: Core Framework (Week 1-2)
Step 2.1: Create Configuration File
File: Core/Config.ps1
powershell# Configuration settings
$script:Config = @{
    CollectionName = "IR-Triage-Collection"
    OutputPath = "$PSScriptRoot\..\Output"
    LogPath = "$PSScriptRoot\..\Logs"
    ToolsPath = "$PSScriptRoot\..\Tools"
    
    # Collection toggles
    CollectMemory = $true
    CollectRegistry = $true
    CollectEventLogs = $true
    CollectPrefetch = $true
    CollectNetworkData = $true
    
    # Event log settings
    EventLogsToCollect = @(
        "Security", "System", "Application",
        "Microsoft-Windows-Sysmon/Operational",
        "Microsoft-Windows-PowerShell/Operational"
    )
    
    # Hash algorithm
    HashAlgorithm = "SHA256"
}
Step 2.2: Build Logging System
File: Core/Logger.ps1
powershellfunction Write-IRLog {
    param(
        [string]$Message,
        [ValidateSet('Info','Warning','Error','Success')]
        [string]$Level = 'Info'
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # Console output with color
    $color = switch($Level) {
        'Info' { 'White' }
        'Warning' { 'Yellow' }
        'Error' { 'Red' }
        'Success' { 'Green' }
    }
    Write-Host $logEntry -ForegroundColor $color
    
    # File output
    $logFile = Join-Path $script:LogPath "IRCollection_$(Get-Date -Format 'yyyyMMdd').log"
    Add-Content -Path $logFile -Value $logEntry
}
Step 2.3: Create Validation Module
File: Utils/Validation.ps1
powershellfunction Test-Administrator {
    $identity = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($identity)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

function Test-DiskSpace {
    param([string]$Path, [int]$RequiredGB = 10)
    
    $drive = (Get-Item $Path).PSDrive
    $freeSpaceGB = [math]::Round($drive.Free / 1GB, 2)
    
    if ($freeSpaceGB -lt $RequiredGB) {
        Write-IRLog "Insufficient disk space: ${freeSpaceGB}GB available, ${RequiredGB}GB required" -Level Error
        return $false
    }
    return $true
}
Phase 3: Volatile Data Collection (Week 2)
Step 3.1: Memory Dump Module
File: Modules/VolatileData.ps1
powershellfunction Get-MemoryDump {
    param([string]$OutputPath)
    
    Write-IRLog "Starting memory acquisition..."
    
    $memoryFile = Join-Path $OutputPath "memory.dmp"
    $dumper = Join-Path $script:ToolsPath "DumpIt.exe"
    
    if (Test-Path $dumper) {
        # Execute memory dumper
        Start-Process -FilePath $dumper -ArgumentList "/O $memoryFile /Q" -Wait -NoNewWindow
        
        if (Test-Path $memoryFile) {
            $hash = Get-FileHash -Path $memoryFile -Algorithm SHA256
            Write-IRLog "Memory dump completed: $($hash.Hash)" -Level Success
            return @{
                FilePath = $memoryFile
                Hash = $hash.Hash
                Size = (Get-Item $memoryFile).Length
            }
        }
    } else {
        Write-IRLog "Memory dumper not found, skipping..." -Level Warning
    }
}
Step 3.2: Running Processes
powershellfunction Get-ProcessList {
    param([string]$OutputPath)
    
    Write-IRLog "Collecting running processes..."
    
    $processes = Get-Process | Select-Object Name, Id, Path, Company, 
        ProductVersion, StartTime, @{N='ParentProcessId';E={$_.ParentId}},
        @{N='CommandLine';E={(Get-CimInstance Win32_Process -Filter "ProcessId=$($_.Id)").CommandLine}}
    
    # Export to multiple formats
    $processes | Export-Csv -Path (Join-Path $OutputPath "processes.csv") -NoTypeInformation
    $processes | ConvertTo-Json -Depth 3 | Out-File (Join-Path $OutputPath "processes.json")
    
    Write-IRLog "Collected $($processes.Count) processes" -Level Success
}
Step 3.3: Network Connections
powershellfunction Get-NetworkConnections {
    param([string]$OutputPath)
    
    Write-IRLog "Collecting network connections..."
    
    $connections = Get-NetTCPConnection | Select-Object LocalAddress, LocalPort,
        RemoteAddress, RemotePort, State, OwningProcess,
        @{N='ProcessName';E={(Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).Name}},
        @{N='ProcessPath';E={(Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).Path}}
    
    $connections | Export-Csv -Path (Join-Path $OutputPath "network_connections.csv") -NoTypeInformation
    
    # Also collect listening ports
    Get-NetTCPConnection -State Listen | Export-Csv -Path (Join-Path $OutputPath "listening_ports.csv") -NoTypeInformation
    
    Write-IRLog "Network data collected" -Level Success
}
Phase 4: Registry Collection (Week 3)
Step 4.1: Registry Hive Extraction
File: Modules/RegistryCollection.ps1
powershellfunction Get-RegistryHives {
    param([string]$OutputPath)
    
    Write-IRLog "Collecting registry hives..."
    
    $regPath = Join-Path $OutputPath "Registry"
    New-Item -ItemType Directory -Path $regPath -Force | Out-Null
    
    # Define critical registry hives
    $hives = @{
        'SAM' = 'C:\Windows\System32\config\SAM'
        'SECURITY' = 'C:\Windows\System32\config\SECURITY'
        'SOFTWARE' = 'C:\Windows\System32\config\SOFTWARE'
        'SYSTEM' = 'C:\Windows\System32\config\SYSTEM'
        'DEFAULT' = 'C:\Windows\System32\config\DEFAULT'
    }
    
    $rawCopy = Join-Path $script:ToolsPath "RawCopy.exe"
    
    foreach ($hive in $hives.GetEnumerator()) {
        try {
            $destination = Join-Path $regPath "$($hive.Key)"
            
            if (Test-Path $rawCopy) {
                # Use RawCopy for locked files
                Start-Process -FilePath $rawCopy -ArgumentList "/FileNamePath:$($hive.Value) /OutputPath:$destination" -Wait -NoNewWindow
            } else {
                # Fallback: reg save command
                reg save "HKLM\$($hive.Key)" "$destination" /y | Out-Null
            }
            
            Write-IRLog "Collected $($hive.Key) hive" -Level Success
        } catch {
            Write-IRLog "Failed to collect $($hive.Key): $_" -Level Error
        }
    }
    
    # Also collect user hives
    Get-UserRegistryHives -OutputPath $regPath
}
Phase 5: Event Log Collection (Week 3)
Step 5.1: Event Log Module
File: Modules/EventLogCollection.ps1
powershellfunction Get-EventLogsCollection {
    param([string]$OutputPath)
    
    Write-IRLog "Collecting event logs..."
    
    $evtxPath = Join-Path $OutputPath "EventLogs"
    New-Item -ItemType Directory -Path $evtxPath -Force | Out-Null
    
    foreach ($logName in $script:Config.EventLogsToCollect) {
        try {
            $log = Get-WinEvent -ListLog $logName -ErrorAction Stop
            $fileName = $logName -replace '/', '-'
            $destination = Join-Path $evtxPath "$fileName.evtx"
            
            # Export event log
            wevtutil epl $logName $destination
            
            if (Test-Path $destination) {
                Write-IRLog "Collected $logName" -Level Success
            }
        } catch {
            Write-IRLog "Failed to collect $logName : $_" -Level Warning
        }
    }
}
Phase 6: File System Artifacts (Week 4)
Step 6.1: Prefetch Collection
File: Modules/FileSystemArtifacts.ps1
powershellfunction Get-PrefetchFiles {
    param([string]$OutputPath)
    
    Write-IRLog "Collecting Prefetch files..."
    
    $prefetchPath = Join-Path $OutputPath "Prefetch"
    New-Item -ItemType Directory -Path $prefetchPath -Force | Out-Null
    
    $source = "C:\Windows\Prefetch\*.pf"
    
    try {
        Copy-Item -Path $source -Destination $prefetchPath -ErrorAction Stop
        $count = (Get-ChildItem $prefetchPath).Count
        Write-IRLog "Collected $count prefetch files" -Level Success
    } catch {
        Write-IRLog "Failed to collect prefetch files: $_" -Level Error
    }
}
Step 6.2: Additional Artifacts
powershellfunction Get-BrowserHistory {
    param([string]$OutputPath)
    # Collect browser history, downloads, cookies
}

function Get-StartupItems {
    param([string]$OutputPath)
    # Collect autoruns, scheduled tasks, services
}

function Get-RecentFiles {
    param([string]$OutputPath)
    # Collect recent files, jump lists, LNK files
}
Phase 7: Chain of Custody (Week 4) NOTE: do later
Step 7.1: Custody Documentation
File: Modules/ChainOfCustody.ps1
powershellfunction New-ChainOfCustody {
    param(
        [string]$OutputPath,
        [hashtable]$CollectionMetadata
    )
    
    Write-IRLog "Generating chain of custody documentation..."
    
    $custody = @{
        CaseInformation = @{
            CollectionID = [guid]::NewGuid().ToString()
            Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            Collector = $env:USERNAME
            SystemName = $env:COMPUTERNAME
            SystemIP = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.InterfaceAlias -notlike "*Loopback*"}).IPAddress
        }
        SystemInformation = @{
            OSVersion = (Get-CimInstance Win32_OperatingSystem).Caption
            OSBuild = (Get-CimInstance Win32_OperatingSystem).BuildNumber
            Architecture = $env:PROCESSOR_ARCHITECTURE
            TimeZone = (Get-TimeZone).Id
            LastBootTime = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
        }
        CollectionDetails = $CollectionMetadata
        FileIntegrity = @{}
    }
    
    # Hash all collected files
    Get-ChildItem -Path $OutputPath -Recurse -File | ForEach-Object {
        $hash = Get-FileHash -Path $_.FullName -Algorithm SHA256
        $relativePath = $_.FullName.Replace($OutputPath, "")
        $custody.FileIntegrity[$relativePath] = @{
            Hash = $hash.Hash
            Size = $_.Length
            Created = $_.CreationTime
            Modified = $_.LastWriteTime
        }
    }
    
    # Export custody document
    $custody | ConvertTo-Json -Depth 5 | Out-File (Join-Path $OutputPath "ChainOfCustody.json")
    
    # Create HTML report
    New-HTMLReport -CustodyData $custody -OutputPath $OutputPath
    
    Write-IRLog "Chain of custody documentation complete" -Level Success
}
Phase 8: Main Orchestration (Week 5)
Step 8.1: Main Collection Script
File: Core/Main-Collector.ps1
powershell<#
.SYNOPSIS
    Automated Incident Response Triage Collection Tool
.DESCRIPTION
    Collects volatile and non-volatile forensic artifacts from Windows systems
#>

param(
    [string]$OutputLocation,
    [switch]$SkipMemory,
    [switch]$QuickMode
)

# Import all modules
. "$PSScriptRoot\Config.ps1"
. "$PSScriptRoot\Logger.ps1"
. "$PSScriptRoot\..\Utils\Validation.ps1"
. "$PSScriptRoot\..\Modules\VolatileData.ps1"
. "$PSScriptRoot\..\Modules\RegistryCollection.ps1"
. "$PSScriptRoot\..\Modules\EventLogCollection.ps1"
. "$PSScriptRoot\..\Modules\FileSystemArtifacts.ps1"
. "$PSScriptRoot\..\Modules\ChainOfCustody.ps1"

function Start-IRCollection {
    Write-Host "`n=== IR Triage Collection Tool ===" -ForegroundColor Cyan
    Write-Host "Starting collection at $(Get-Date)`n"
    
    # Pre-flight checks
    if (-not (Test-Administrator)) {
        Write-IRLog "This script requires administrator privileges!" -Level Error
        exit 1
    }
    
    # Create output directory
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $collectionPath = Join-Path $script:Config.OutputPath "${timestamp}_$env:COMPUTERNAME"
    New-Item -ItemType Directory -Path $collectionPath -Force | Out-Null
    
    Write-IRLog "Output directory: $collectionPath" -Level Info
    
    # Check disk space
    if (-not (Test-DiskSpace -Path $collectionPath -RequiredGB 10)) {
        exit 1
    }
    
    $collectionMetadata = @{
        StartTime = Get-Date
        Modules = @()
    }
    
    # Collection sequence (order by volatility)
    try {
        # 1. Memory (most volatile)
        if (-not $SkipMemory -and $script:Config.CollectMemory) {
            $memResult = Get-MemoryDump -OutputPath $collectionPath
            $collectionMetadata.Modules += @{Name="Memory"; Result=$memResult}
        }
        
        # 2. Running processes and network
        if ($script:Config.CollectNetworkData) {
            Get-ProcessList -OutputPath $collectionPath
            Get-NetworkConnections -OutputPath $collectionPath
            $collectionMetadata.Modules += "Volatile Data"
        }
        
        # 3. Registry hives
        if ($script:Config.CollectRegistry) {
            Get-RegistryHives -OutputPath $collectionPath
            $collectionMetadata.Modules += "Registry"
        }
        
        # 4. Event logs
        if ($script:Config.CollectEventLogs) {
            Get-EventLogsCollection -OutputPath $collectionPath
            $collectionMetadata.Modules += "Event Logs"
        }
        
        # 5. File system artifacts
        if ($script:Config.CollectPrefetch) {
            Get-PrefetchFiles -OutputPath $collectionPath
            Get-StartupItems -OutputPath $collectionPath
            $collectionMetadata.Modules += "File System Artifacts"
        }
        
        # Generate chain of custody
        $collectionMetadata.EndTime = Get-Date
        $collectionMetadata.Duration = ($collectionMetadata.EndTime - $collectionMetadata.StartTime).TotalMinutes
        
        New-ChainOfCustody -OutputPath $collectionPath -CollectionMetadata $collectionMetadata
        
        # Compress collection
        Compress-Collection -SourcePath $collectionPath
        
        Write-Host "`n=== Collection Complete ===" -ForegroundColor Green
        Write-Host "Total time: $([math]::Round($collectionMetadata.Duration, 2)) minutes"
        Write-Host "Output: $collectionPath"
        
    } catch {
        Write-IRLog "Collection failed: $_" -Level Error
        throw
    }
}

# Execute collection
Start-IRCollection
Phase 9: Testing & Validation (Week 5-6)
Step 9.1: Create Test Cases
powershell# Test on different Windows versions
# - Windows 10 (various builds)
# - Windows 11
# - Windows Server 2016/2019/2022

# Test scenarios:
# 1. Normal execution with all privileges
# 2. Execution with insufficient disk space
# 3. Execution without admin rights
# 4. Collection with missing external tools
# 5. Collection on system with Sysmon installed
# 6. Quick mode vs full collection
Step 9.2: Verification Checklist

 All artifacts collected successfully
 File hashes match in chain of custody
 Timestamps are accurate
 Compression works correctly
 Memory dump is valid (test with Volatility)
 Event logs can be opened in Event Viewer
 Registry hives can be loaded in Registry Explorer
 Error handling works for missing files
 Logging is comprehensive

Phase 10: Documentation & Packaging (Week 6)
Step 10.1: Create README.md
markdown# IR Triage Collection Tool

## Features
- Automated collection of volatile data
- Memory acquisition
- Registry hive extraction
- Event log collection
- Chain of custody documentation

## Requirements
- Windows 10/11 or Server 2016+
- PowerShell 5.1+
- Administrator privileges
- 10GB free disk space

## Usage
```powershell
.\Main-Collector.ps1
```

## Output Structure
[Document the output directory structure]
Step 10.2: Create User Guide

Installation instructions
Configuration options
Usage examples
Troubleshooting guide
Artifact analysis recommendations

Additional Enhancements (Optional)
Week 7+:

Remote Collection: Add PSRemoting support for remote systems
GUI Interface: Build simple WPF interface
Parallel Collection: Speed up collection with runspaces
Cloud Upload: Auto-upload to secure storage
Report Generation: Enhanced HTML/PDF reports
Integrity Verification: Digital signatures for evidence
Selective Collection: Profiles for different scenarios
Timeline Generation: Auto-parse artifacts into timeline
KAPE Integration: Interface with Kroll Artifact Parser
API Integration: Send data to SIEM/SOAR platforms

Key Success Metrics
✅ Functionality: Collects all specified artifacts reliably
✅ Performance: Completes collection in <30 minutes
✅ Reliability: Handles errors gracefully
✅ Documentation: Clear chain of custody
✅ Usability: Simple execution for responders
✅ Forensic Soundness: Maintains evidence integrity
This project demonstrates enterprise-ready skills in PowerShell automation, Windows forensics, incident response procedures, and evidence handling—exactly what employers are looking for!